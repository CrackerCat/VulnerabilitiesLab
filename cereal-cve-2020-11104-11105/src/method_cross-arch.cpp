#include <string>
#include <sstream>
#include <stdio.h>
#include <unistd.h>
#include "method_cross-arch.h"
#include "archives.h"
#include "serialize-helper.h"

namespace cereal {
namespace fuzzer {
namespace method {

namespace cross_arch_detail {
    std::string generateTmpFilename(void) {
        static size_t i;

        /* TODO portable solution */
        return std::string("/tmp/cereal-fuzzer-") + std::to_string(++i);
    }

    template <class OutputArchiveType>
    void test(const std::string outputArchiveName, fuzzing::datasource::Datasource& ds) {
        const auto inFileTypes = generateTmpFilename();
        const auto inFileArchive = generateTmpFilename();
        const auto outFile = generateTmpFilename();

        if ( inFileTypes == outFile || inFileTypes == inFileArchive ) {
            /* Unlikely */
            return;
        }

        /* Get types */
        const auto typeInfos = getTypeInfos(ds);
        if ( typeInfos.empty() ) {
            return;
        }

        /* Serialize */
        std::stringstream ss;
        uint64_t hashFromSerialization;
        {
            OutputArchiveType archiveTo(ss);
            hashFromSerialization = serializeFromTypes<OutputArchiveType>(archiveTo, typeInfos, &ds);
        }

        /* Write types to inFileTypes */
        {
            FILE* fp = fopen(inFileTypes.c_str(), "wb"); if ( !fp ) abort();
            for (const auto& typeInfo : typeInfos) {
                if ( fwrite(&typeInfo.type, sizeof(typeInfo.type), 1, fp) != 1 ) abort();
                if ( fwrite(&typeInfo.super, sizeof(typeInfo.super), 1, fp) != 1 ) abort();
            }
            fclose(fp);
        }

        /* Write archive to inFileArchive */
        {
            const auto asString = ss.str();
            if ( asString.empty() ) {
                /* Don't perform any tests on an empty archive */
                return;
            }
            FILE* fp = fopen(inFileArchive.c_str(), "wb"); if ( !fp ) abort();
            if ( fwrite(asString.data(), asString.size(), 1, fp) != 1 ) abort();
            fclose(fp);
        }

        /* Execute other arch deserializer */
        {
            /* Ensure the output file does not exist */
            unlink(outFile.c_str());

            /* TODO resolve full path of deserialize32 so the fuzzer can be run from other directories */
            const std::string command = std::string("./deserialize32") + " " + outputArchiveName + " " + inFileTypes + " " + inFileArchive + " " + outFile;

            /* TODO check for deserialize32 crashes */
            system(command.c_str());
        }

        uint64_t crossArchHash;
        {
            FILE* fp = fopen(outFile.c_str(), "rb"); if ( !fp ) abort();
            if ( fread(&crossArchHash, sizeof(crossArchHash), 1, fp) != 1 ) abort();
            fclose(fp);
        }

        if (    hashFromSerialization != crossArchHash &&
                ignoreHashMismatch(typeInfos) == false ) {
            fprintf(stderr, "Cross-arch hash mismatch\n");
            abort();
        }

        unlink(inFileTypes.c_str());
        unlink(inFileArchive.c_str());
        unlink(outFile.c_str());
    }
} /* namespace cross_arch_detail */

void testCrossArch(const std::vector<uint8_t>& dsData) {
    fuzzing::datasource::Datasource ds(dsData.data(), dsData.size());

    const uint8_t which = ds.Get<uint8_t>();

    switch ( which ) {
        case    0:
            cross_arch_detail::test<BinaryOutputArchive>("Binary", ds);
            break;
        case    1:
            cross_arch_detail::test<PortableBinaryOutputArchive>("PortableBinary", ds);
            break;
        case    2:
            cross_arch_detail::test<XMLOutputArchive>("XML", ds);
            break;
        case    3:
            cross_arch_detail::test<JSONOutputArchive>("JSON", ds);
            break;
    }
}

} /* namespace method */
} /* namespace fuzzer */
} /* namespace cereal */
