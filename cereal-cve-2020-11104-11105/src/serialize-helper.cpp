#include "serialize-helper.h"
#include "exceptions.h"
#include "hasher.h"
#include "archives.h"
#include "meta.h"
#include "serialize.h"

namespace cereal {
namespace fuzzer {

/* Select a type enum (from either kDataType or kDataSuperType) */
template <class TypeEnum>
TypeEnum getType(fuzzing::datasource::Datasource& ds) {
    const auto typeId = ds.Get<uint8_t>();

    /* If the extracted value is invalid, bail early, so that
     * type handlers always operate on valid types.
     */
    if ( typeId >= static_cast<uint8_t>(TypeEnum::Last) ) {
        throw RecoverableError();
    }

    return static_cast<TypeEnum>(typeId);
}

/* Extract a sequence of data type, super type pairs from the Datasource.
 *
 * XXX: Enforce a maximum amount to prevent timeouts with long inputs.
 */
std::vector<TypeInfo> getTypeInfos(fuzzing::datasource::Datasource& ds) {
    std::vector<TypeInfo> typeInfos;

    while ( ds.Get<bool>() == true ) {
        typeInfos.push_back( {getType<kDataType>(ds), getType<kDataSuperType>(ds)} );
    }

    return typeInfos;
}

/* - For each type:
 *   - Create a value
 *   - Update the hash stream with the value
 *   - Serialize the value
 *   - Compute and save the final hash
 */
template <class OutputArchiveType>
uint64_t serializeFromTypes(OutputArchiveType& archiveTo, const std::vector<TypeInfo>& typeInfos, fuzzing::datasource::Datasource* ds) {
    Hasher hasher;

    for (const auto& typeInfo : typeInfos) {
        ::cereal::fuzzer::serialize<OutputArchiveType>(archiveTo, typeInfo, ds, &hasher);
    }

    return hasher.GetHash();
}

/* Explicit instantiation */
template uint64_t serializeFromTypes(XMLOutputArchive& archiveTo, const std::vector<TypeInfo>& typeInfos, fuzzing::datasource::Datasource* ds);
template uint64_t serializeFromTypes(JSONOutputArchive& archiveTo, const std::vector<TypeInfo>& typeInfos, fuzzing::datasource::Datasource* ds);
template uint64_t serializeFromTypes(BinaryOutputArchive& archiveTo, const std::vector<TypeInfo>& typeInfos, fuzzing::datasource::Datasource* ds);
template uint64_t serializeFromTypes(PortableBinaryOutputArchive& archiveTo, const std::vector<TypeInfo>& typeInfos, fuzzing::datasource::Datasource* ds);

/* - For each type:
 *   - Deserialize the value
 *   - Update the hash stream with the value
 *   - Compute and save the final hash
 */
template <class InputArchiveType, bool Hash>
uint64_t serializeToTypes(InputArchiveType& archiveFrom, const std::vector<TypeInfo>& typeInfos) {
    Hasher hasher;

    for (const auto& typeInfo : typeInfos) {
        ::cereal::fuzzer::serialize<InputArchiveType, true>(archiveFrom, typeInfo, nullptr, Hash ? &hasher : nullptr);
    }

    if ( Hash == true ) {
        return hasher.GetHash();
    } else {
        return 0;
    }
}

/* Explicit instantiation */
template uint64_t serializeToTypes<cereal::XMLInputArchive, true>(cereal::XMLInputArchive& archiveFrom, const std::vector<TypeInfo>& typeInfos);
template uint64_t serializeToTypes<cereal::JSONInputArchive, true>(cereal::JSONInputArchive& archiveFrom, const std::vector<TypeInfo>& typeInfos);
template uint64_t serializeToTypes<cereal::BinaryInputArchive, true>(cereal::BinaryInputArchive& archiveFrom, const std::vector<TypeInfo>& typeInfos);
template uint64_t serializeToTypes<cereal::PortableBinaryInputArchive, true>(cereal::PortableBinaryInputArchive& archiveFrom, const std::vector<TypeInfo>& typeInfos);

template uint64_t serializeToTypes<cereal::XMLInputArchive, false>(cereal::XMLInputArchive& archiveFrom, const std::vector<TypeInfo>& typeInfos);
template uint64_t serializeToTypes<cereal::JSONInputArchive, false>(cereal::JSONInputArchive& archiveFrom, const std::vector<TypeInfo>& typeInfos);
template uint64_t serializeToTypes<cereal::BinaryInputArchive, false>(cereal::BinaryInputArchive& archiveFrom, const std::vector<TypeInfo>& typeInfos);
template uint64_t serializeToTypes<cereal::PortableBinaryInputArchive, false>(cereal::PortableBinaryInputArchive& archiveFrom, const std::vector<TypeInfo>& typeInfos);

/* Some types will not deserialize into the exact original binary value.
 * Return true is typeInfos contains such a type, false otherwise.
 */
bool ignoreHashMismatch(const std::vector<TypeInfo>& typeInfos) {
    for (const auto& typeInfo : typeInfos) {
        switch ( typeInfo.type ) {
            /* The following types appear to not deserialize into the original binary values */
            /*
             * NOTE: These were previously enabled for testing purposes.
             *       You may add type identifiers here if you wish to ignore
             *       serialization asymmetry of a specific type.
             *
            case kDataType::LongDouble:
            case kDataType::StdComplexLongDouble:
                return true;
            case kDataType::StdString:
                return true;
            */
            default:
                /* Do nothing, continue iterating */
                break;
        }
    }

    return false;
}

} /* namespace fuzzer */
} /* namespace cereal */
