#include <string>
#include "method_serialization-symmetry.h"
#include "archives.h"
#include "serialize-helper.h"
#include "util.h"

namespace cereal {
namespace fuzzer {
namespace method {

namespace serialization_symmetry_detail {

template <class InputArchive> bool IsBinary(void) {
    static_assert("Unsupported input archive type");

    /* Never reached; silence -Wreturn-type */
    return false;
}

template <> bool IsBinary<cereal::BinaryInputArchive>(void) { return true; }
template <> bool IsBinary<cereal::PortableBinaryInputArchive>(void) { return true; }
template <> bool IsBinary<cereal::JSONInputArchive>(void) { return false; }
template <> bool IsBinary<cereal::XMLInputArchive>(void) { return false; }

/* 1. Construct a list of types
 *
 * 2. Serialization
 *    - For each type:
 *      - Create a value
 *      - Update the hash stream with the value
 *      - Serialize the value
 *    - Compute and save the final hash
 *
 * 3. Deserialization
 *    - For each type:
 *      - Deserialize the value
 *      - Update the hash stream with the value
 *      - Compute and save the final hash
 *
 * 4. Symmetry assertion
 *    Compare both computed hashes and abort on mismatch
 */
template <class OutputArchiveType, class InputArchiveType>
void test(fuzzing::datasource::Datasource& ds) {
#if defined(DEBUG)
    std::cout << "Enter " << std::string(__FUNCTION__) << std::endl;
#endif

    std::stringstream ss;

    /* Get types */
    const auto typeInfos = getTypeInfos(ds);

    /* Serialize */
    uint64_t hashFromSerialization;
    {
        /* 'archiveTo' is explicitly scoped, because object destruction is required to enforce flushing.
         * According to the cereal documentation:
         *
         * "Some archives in cereal can only safely finish flushing their contents upon their destruction.
         * Make sure, especially for output serialization, that your archive is automatically destroyed
         * when you are finished with it."
         */
        OutputArchiveType archiveTo(ss);
        hashFromSerialization = serializeFromTypes<OutputArchiveType>(archiveTo, typeInfos, &ds);
    }

    {
        const std::string asString = ss.str();

        /* Test ss for unininitialized data */
        memory_test(asString.data(), asString.size());

        if ( asString.empty() ) {
            /* cereal will throw an exception if the input stream is empty */
            return;
        }
    }

    /* Deserialization */
    {

        /* Decide whether to transform into an intermediate container */
        {
            const uint8_t whichIntermediateFormat = ds.Get<uint8_t>();

            switch ( whichIntermediateFormat ) {
                case    0:
#if defined(DEBUG)
                    std::cout << std::string("Intermediate format: std::string") << std::endl;
#endif
                    /* Re-initialize the stringstream with the serialized data as an std::string.
                     *
                     * std::string should account for embedded null bytes, but test this to be
                     * sure that deserialization will succeed in this case.
                     */
                    ss = std::stringstream(ss.str());
                    break;
                case    1:
                    if ( IsBinary<InputArchiveType>() == false ) {
#if defined(DEBUG)
                        std::cout << std::string("Intermediate format: char*") << std::endl;
#endif
                        /* Re-initialize the stringstream with the serialized data as a null-terminated string.
                         *
                         * This explores whether deserialization will succeed if the JSON or XML archive
                         * contains a null byte. A null byte might be introduced by attempting to serialize
                         * binary data (eg. a std::string, an unsigned char, ...).
                         *
                         * Users of cereal may treat JSON and XML archives as ASCII data, and as such truncation
                         * at a null byte boundary can reasonably occur.
                         *
                         */
                        ss = std::stringstream(std::string(ss.str().c_str()));
                    }
                    break;
                default:
#if defined(DEBUG)
                    std::cout << std::string("Intermediate format: std::stringstream") << std::endl;
#endif
                    break;
            }
        }

        /* Initialize */
        InputArchiveType archiveFrom(ss);

        /* Deserialize and retrieve hash */
        const uint64_t hashFromDeserialization = serializeToTypes<InputArchiveType>(archiveFrom, typeInfos);

        /* Assert symmetry */
        if (    hashFromSerialization != hashFromDeserialization &&
                ignoreHashMismatch(typeInfos) == false ) {
            fprintf(stderr, "Hash mismatch. This probably means there is a bug in serialization\n");

            /* As intended, Mayhem will treat an abort() as a bug. */
            abort();
        }
    }
}

} /* namespace serialization_symmetry_detail */

/* Choose an archive type, and launch the handler for that type */
void testSerializationSymmetry(const std::vector<uint8_t>& dsData) {
    fuzzing::datasource::Datasource ds(dsData.data(), dsData.size());

    const uint8_t which = ds.Get<uint8_t>();

    switch ( which ) {
        case    0:
#if defined(DEBUG)
            std::cout << std::string(__FUNCTION__) << ": Archive type: Binary" << std::endl;
#endif
            serialization_symmetry_detail::test<cereal::BinaryOutputArchive, cereal::BinaryInputArchive>(ds);
            break;
        case    1:
#if defined(DEBUG)
            std::cout << std::string(__FUNCTION__) << ": Archive type: Portable Binary" << std::endl;
#endif
            serialization_symmetry_detail::test<cereal::PortableBinaryOutputArchive, cereal::PortableBinaryInputArchive>(ds);
            break;
        case    2:
#if defined(DEBUG)
            std::cout << std::string(__FUNCTION__) << ": Archive type: XML" << std::endl;
#endif
            serialization_symmetry_detail::test<cereal::XMLOutputArchive, cereal::XMLInputArchive>(ds);
            break;
        case    3:
#if defined(DEBUG)
            std::cout << std::string(__FUNCTION__) << ": Archive type: JSON" << std::endl;
#endif
            serialization_symmetry_detail::test<cereal::JSONOutputArchive, cereal::JSONInputArchive>(ds);
            break;
    }
}

} /* namespace method */
} /* namespace fuzzer */
} /* namespace cereal */
