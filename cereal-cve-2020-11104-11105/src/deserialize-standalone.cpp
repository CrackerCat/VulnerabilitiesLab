#include "shared_includes.h"

template <class InputArchiveType>
static uint64_t deserialize(std::stringstream& ss, const std::vector<cereal::fuzzer::TypeInfo>& typeInfos) {
    InputArchiveType archiveFrom(ss);
    return cereal::fuzzer::serializeToTypes<InputArchiveType>(archiveFrom, typeInfos);
}

int main(int argc, char** argv)
{
    if ( argc != 5 ) {
        fprintf(stderr, "Incorrect arguments\n");
        abort();
    }

    const auto outputArchiveName = std::string(argv[1]);
    const auto inFileTypes = std::string(argv[2]);
    const auto inFileArchive = std::string(argv[3]);
    const auto outFileHash = std::string(argv[4]);

    if (    outputArchiveName != std::string("Binary") &&
            outputArchiveName != std::string("PortableBinary") &&
            outputArchiveName != std::string("XML") &&
            outputArchiveName != std::string("JSON") ) {
        fprintf(stderr, "Invalid archive type\n");
        abort();
    }

    /* Get types */
    std::vector<cereal::fuzzer::TypeInfo> typeInfos;
    {
        FILE* fp = fopen(inFileTypes.c_str(), "rb"); if ( !fp ) abort();
        long size;

        /* Resolve file size */
        {
            fseek(fp, 0L, SEEK_END);
            size = ftell(fp);
            if ( size < 2 ) {
                abort();
            }
            fseek(fp, 0L, SEEK_SET);
        }

        /* Read/load types */
        for (long i = 0; i < size; i += 2) {
            cereal::fuzzer::TypeInfo typeInfo;
            if ( fread(&typeInfo.type, sizeof(typeInfo.type), 1, fp) != 1 ) abort();
            if ( fread(&typeInfo.super, sizeof(typeInfo.super), 1, fp) != 1 ) abort();

            typeInfos.push_back(typeInfo);
        }

        fclose(fp);
    }

    /* Load serialized data */
    std::string serialized;
    {
        FILE* fp = fopen(inFileArchive.c_str(), "rb"); if ( !fp ) abort();
        long size;

        /* Resolve file size */
        {
            fseek(fp, 0L, SEEK_END);
            size = ftell(fp);
            if ( size < 0 ) {
                abort();
            }
            fseek(fp, 0L, SEEK_SET);
        }

        /* Allocate */
        std::vector<uint8_t> v;
        v.resize(size);

        /* Read entire file */
        if ( size ) {
            if ( fread(v.data(), size, 1, fp) != 1 ) abort();
        }

        fclose(fp);

        /* To std::string, for use with std::stringstream */
        serialized = std::string(v.data(), v.data() + size);
    }

    /* Deserialize */
    uint64_t hashFromDeserialization;
    try {
        std::stringstream ss(serialized);
        if ( outputArchiveName == std::string("Binary") ) {
            hashFromDeserialization = deserialize<cereal::BinaryInputArchive>(ss, typeInfos);
        } else if ( outputArchiveName == std::string("PortableBinary") ) {
            hashFromDeserialization = deserialize<cereal::PortableBinaryInputArchive>(ss, typeInfos);
        } else if ( outputArchiveName == std::string("XML") ) {
            hashFromDeserialization = deserialize<cereal::XMLInputArchive>(ss, typeInfos);
        } else if ( outputArchiveName == std::string("JSON") ) {
            hashFromDeserialization = deserialize<cereal::JSONInputArchive>(ss, typeInfos);
        }
    } catch ( ... ) { return 0; }

    /* Write hash */
    {
        FILE* fp = fopen(outFileHash.c_str(), "wb"); if ( !fp ) abort();
        if ( fwrite(&hashFromDeserialization, sizeof(hashFromDeserialization), 1, fp) != 1 ) abort();
        fclose(fp);
    }

    return 0;
}
