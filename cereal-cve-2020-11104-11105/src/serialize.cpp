#include "serialize.h"

#include "serialize_type.h"
#include "serialize_vector_type.h"
#include "serialize_array_type.h"
#include "serialize_deque_type.h"
#include "serialize_set_type.h"
#include "serialize_atomic_type.h"
#include "serialize_optional_type.h"
#include "serialize_list_type.h"
#include "serialize_stack_type.h"
#include "serialize_queue_type.h"
#include "serialize_map_type.h"
#include "serialize_tuple2_type.h"
#include "serialize_tuple3_type.h"
#include "serialize_sharedptr_type.h"
#include "serialize_uniqueptr_type.h"

#include "archives.h"
#include "meta.h"
#include "exceptions.h"

namespace cereal {
namespace fuzzer {

template <class ArchiveType, bool Deserialize>
void serialize(ArchiveType& archive, const TypeInfo& typeInfo, fuzzing::datasource::Datasource* ds, Hasher* hasher) {
#if defined(DEBUG)
        std::cout << std::string(__FUNCTION__) << "(): " << magic_enum::enum_name(typeInfo.super) << ", " << magic_enum::enum_name(typeInfo.type) << std::endl;
#endif

    /* Hash the data types */
    if ( hasher != nullptr ) hasher->Hash(typeInfo.type);
    if ( hasher != nullptr ) hasher->Hash(typeInfo.super);

    if ( typeInfo.super == kDataSuperType::None ) {

        switch ( typeInfo.type ) {
            #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                FOR_ALL_TYPES(CALL_TYPE_HANDLER);
            #undef CALL_TYPE_HANDLER

            case    kDataType::CustomType: serializeCustomType<ArchiveType, Deserialize>(archive, ds, hasher); break;

            default:
                throw RecoverableError();
        }
    } else {
        switch ( typeInfo.super ) {
            case  kDataSuperType::Vector:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeVectorType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Array:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeArrayType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Deque:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeDequeType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Set:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeSetType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES_3(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Atomic:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeAtomicType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES_2(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Optional:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeOptionalType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::List:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeListType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Stack:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeStackType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Queue:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeQueueType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Map:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeMapType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Tuple2:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeTuple2Type<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::Tuple3:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeTuple3Type<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::StdUniquePtr:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeStdUniquePtrType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;

            case  kDataSuperType::StdSharedPtr:
                {
                    switch ( typeInfo.type ) {
                        #define CALL_TYPE_HANDLER(type, kdatatype) case    kdatatype: serializeStdSharedPtrType<ArchiveType, type, Deserialize>(archive, ds, hasher); break;
                            FOR_ALL_TYPES(CALL_TYPE_HANDLER);
                        #undef CALL_TYPE_HANDLER

                        default:
                            throw RecoverableError();
                    }
                }
                break;
            default:
                throw RecoverableError();
        }
    }
}

/* Explicit instantiations */
#define INSTANTIATE(archive, deserialize, type) \
    template void serialize<archive, deserialize>(archive& _archive, const TypeInfo& typeInfo, fuzzing::datasource::Datasource* ds, Hasher* hasher);

FOR_ALL_ARCHIVES(INSTANTIATE, 0);

#undef INSTANTIATE

} /* namespace fuzzer */
} /* namespace cereal */
