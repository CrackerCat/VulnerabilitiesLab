#define archiveWithNVP() \
    /* Choose whether to serialize as a name-value pair, or plain */ \
    if ( ds && ds->Get<bool>() ) { \
        const auto name = ds->Get<std::string>(); \
        archive(cereal::make_nvp(name, v)); \
    } else { \
        archive(v); \
    }

template <class T> bool isnan(const T v) { return false; }

template <> bool isnan<>(const float v) { return !std::isnormal(v); }
template <> bool isnan<>(const double v) { return !std::isnormal(v); }
template <> bool isnan<>(const long double v) { return !std::isnormal(v); }
template <> bool isnan<>(const std::complex<float> v) { return !std::isnormal(v.real()) || !std::isnormal(v.imag()); }
template <> bool isnan<>(const std::complex<double> v) { return !std::isnormal(v.real()) || !std::isnormal(v.imag()); }
template <> bool isnan<>(const std::complex<long double> v) { return !std::isnormal(v.real()) || !std::isnormal(v.imag()); }

template <class T>
T GetValue(fuzzing::datasource::Datasource* ds) {
    const auto v = ds->Get<T>();
    if ( isnan(v) == true ) {
        throw RecoverableError();
    }
    return v;
}

template <class ArchiveType, class Type, bool Deserialize>
void serializeType(ArchiveType& archive, fuzzing::datasource::Datasource* ds, Hasher* hasher) {
    Type v;
    if ( Deserialize == false ) {
        v = GetValue<Type>(ds);
        archiveWithNVP();
    } else {
        archive(v);
    }

#if defined(DEBUG)
    if ( Deserialize == false ) {
        std::cout << "serialized value: " << v << std::endl;
    } else {
        std::cout << "deserialized value: " << v << std::endl;
    }
#endif

    /* Hash the value */
    if ( hasher != nullptr ) hasher->Hash(v);
}
