#include "hasher.h"
#include "typeinfo.h"
#include "types.h"
#include "meta.h"
#include "limits.h"

#include <array>
#include <deque>
#include <set>
#include <list>
#include <atomic>

namespace cereal {
namespace fuzzer {

Hasher::Hasher(void) : state(XXH64_createState()) {
    XXH64_reset(state, 0);
}

Hasher::~Hasher() {
    XXH64_freeState(state);
}

void Hasher::Hash(const void* data, const size_t size) {
    if ( size == 0 ) {
        return;
    }

    if ( XXH64_update(state, data, size) == XXH_ERROR ) {
        fprintf(stderr, "XXhash error\n");
        abort();
    }
}

/* The general case: hash the raw memory of the variable */
template <class T>
void Hasher::Hash(const T& v) {
    Hash(&v, sizeof(v));
}

/* long double is special: Only the first 80 bits are relevant,
 * the rest is padding and consists of uninitialized memory
 */
void Hasher::Hash(const long double& ld) {
    constexpr size_t long_double_bits = 80;
    constexpr size_t long_double_bytes = long_double_bits / 8;
    static_assert(sizeof(ld) >= long_double_bytes);
    Hash(&ld, long_double_bytes);
}

/* Hash the both components of the complex type separately */
void Hasher::Hash(const std::complex<long double>& v) {
    Hash(v.real());
    Hash(v.imag());
}

void Hasher::Hash(const std::string& s) {
    Hash(s.data(), s.size());
}

void Hasher::Hash(const std::chrono::duration<int, std::centi>& d) {
    const auto count = d.count();
    Hash(&count, sizeof(count));
}

void Hasher::Hash(const CustomType& c) {
    Hash(c.data.data(), c.data.size());
}

uint64_t Hasher::GetHash(void) {
    return XXH64_digest(state);
}

/* Explicit instantiations */

    /* Basic types */
    #define INSTANTIATE(type) \
        template void Hasher::Hash(const type& v);

    INSTANTIATE(kDataType);
    INSTANTIATE(kDataSuperType);
    INSTANTIATE(bool)
    INSTANTIATE(char)
    INSTANTIATE(signed char)
    INSTANTIATE(unsigned char)
    INSTANTIATE(signed short)
    INSTANTIATE(unsigned short)
    INSTANTIATE(signed int)
    INSTANTIATE(unsigned int)
    INSTANTIATE(signed long)
    INSTANTIATE(unsigned long)
    INSTANTIATE(float)
    INSTANTIATE(double)
    INSTANTIATE(std::complex<float>)
    INSTANTIATE(std::complex<double>)
    INSTANTIATE(std::bitset<256>)
    INSTANTIATE(signed long long)
    INSTANTIATE(unsigned long long)

    #undef INSTANTIATE

    /* All supported std::atomic types */
    #define INSTANTIATE(type, kdatatype) \
        template void Hasher::Hash(const std::atomic<type>& v);

    FOR_ALL_TYPES_2(INSTANTIATE);

    #undef INSTANTIATE

    /* hashContainer for all container types that support standard iteration */
    #define INSTANTIATE(type, kdatatype) \
        template void hashContainer<std::vector<type>>(const std::vector<type>& container, Hasher* hasher); \
        template void hashContainer<std::array<type, kArraySize>>(const std::array<type, kArraySize>& container, Hasher* hasher); \
        template void hashContainer<std::deque<type>>(const std::deque<type>& container, Hasher* hasher); \
        template void hashContainer<std::set<type>>(const std::set<type>& container, Hasher* hasher); \
        template void hashContainer<std::list<type>>(const std::list<type>& container, Hasher* hasher);

    FOR_ALL_TYPES(INSTANTIATE);

    #undef INSTANTIATE

} /* namespace fuzzer */
} /* namespace cereal */
