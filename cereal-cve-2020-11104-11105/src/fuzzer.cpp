#include "shared_includes.h"
#include "exceptions.h"

#include <fuzzing/datasource/datasource.hpp>

#if !defined(STANDALONE)
#include <fuzzing/dictionary/dictionary.h>
#include "mutator.h"
#endif

/* Test method implementations */
#include "method_serialization-symmetry.h"
#include "method_untrusted-deserialization.h"
#if !defined(NO_CROSSARCH)
  #include "method_cross-arch.h"
#endif

namespace cereal {
namespace fuzzer {

/*
 * Choose one of multiple testing method, and launch the handler for this method.
 */
void entry(const uint8_t *data, size_t size) {
    fuzzing::datasource::Datasource ds(data, size);

    try {
        const auto mode = ds.Get<uint8_t>();
        const auto dsData = ds.GetData(0);

        switch ( mode ) {
            case    0:
                try {
                    method::testUntrustedDeserialization(dsData);

                /* cereal::Exception is expected to be thrown if input data is not well-formed. */
                } catch ( cereal::Exception& ) { }
                break;
            case    1:
                /* Intentionally not catching exceptions here:
                 * Serialization and subsequent deserialization should always succeed.
                 */
                method::testSerializationSymmetry(dsData);
                break;
            case    2:
#if !defined(NO_CROSSARCH)
                method::testCrossArch(dsData);
#endif
                break;
        }
    } catch ( fuzzing::datasource::Base::OutOfData& ) { }
      catch ( RecoverableError& ) { }
}

} /* namespace fuzzer */
} /* namespace cereal */

extern "C" int LLVMFuzzerInitialize(int *argc, char ***argv) {
    (void)argc;
    (void)argv;

    /* No mutators needed in standalone mode */
#if !defined(STANDALONE)
    cereal::fuzzer::initializeMutator();
#endif

    return 0;
}

/* libFuzzer entry point */
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    cereal::fuzzer::entry(data, size);
    return 0;
}

#if defined(STANDALONE)
int main(int argc, char** argv) {
    if ( argc != 2 ) {
        fprintf(stderr, "Incorrect arguments\n");
        abort();
    }

    FILE* fp = fopen(argv[1], "rb"); if ( !fp ) abort();
    long size;

    /* Resolve file size */
    {
        fseek(fp, 0L, SEEK_END);
        size = ftell(fp);
        if ( size < 0 ) {
            abort();
        }
        fseek(fp, 0L, SEEK_SET);
    }

    uint8_t* data = (uint8_t*)malloc(size);
    if ( fread(data, size, 1, fp) != 1 ) abort();

    LLVMFuzzerInitialize(&argc, &argv);
    LLVMFuzzerTestOneInput(data, (size_t)size);

    free(data);

    fclose(fp);

    return 0;
}
#endif

