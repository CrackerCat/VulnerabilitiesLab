# Cereal CVE-2020-11104 and CVE-2020-11105

This image builds several libfuzzer targets for
[cereal](https://uscilab.github.io/cereal/), a popular header-only
serialization library.  It builds fuzzers for
[CVE-2020-11104](https://nvd.nist.gov/vuln/detail/CVE-2020-11104) and
[CVE-2020-11105](https://nvd.nist.gov/vuln/detail/CVE-2020-11105).

Beyond the CVEs, this repository is interesting for anyone interested
in building header-only library fuzzers. A full write up of these
issues, as well as several other demonstrated in the (poc)[./poc]
directory, on our [blog](https://blog.forallsecure.com).


## Building

Cereal is header-only for C++ using templates.  Building the fuzzer
enumerates the various template types, and eats up a ton of RAM.  We
recommend you allocate at least 10GB to your docker host.

To build, run:
```bash
docker build -t cereal-cve-2020-11104,11105 .
```

Then go get a coffee.

## Running

We've included within the docker image the harnesses under
`/src/cereal/fuzzer`.  You can run within the docker image:


```
docker run -ti cereal-cve-2020-11104-111105 bash
```

We also include a number of POCs which you can compile. You should be
able to run all the POCs from the `/src/poc` directory within the
docker image.

## Runtime error checks

- AddressSanitizer
- UndefinedBehaviorSanitizer
- ```-D_GLIBCXX_DEBUG```. This enables the debug versions of STL types, sometimes finding errors that the sanitizers don't.

## Harness components

### Asserting serialization symmetry

1. Generate a set of data types to serialize (from the input)

2. - For each data type, generate a value (from the input)
   - Serialize this value
   - Hash (raw data of) the value (using XXHash)
   - Retrieve and store the aggregate hash

3. - From the generated serialized data:
   - Deserialize the value of each type in the type set generated in 1)
   - Hash (raw data of) the value (using XXHash)
   - Retrieve and store the aggregate hash

4. Compare both hashes, and abort if there is a mismatch, as this
   indicates a serialization bug.

[XXHash](https://github.com/Cyan4973/xxHash), included with this
project, is used for hashing.

### Deserialization from untrusted data

Catch memory bugs and crashes from parsing untrusted data.

### Cross-arch serialization

Assert that data integrity is not affected when serializing between 64
bit and 32 bit. This is achieved by launching the external standalone
32 bit deserializer, and comparing the hash that this produces with
the hash resulting from 64 bit serialization.

### Binaries

The ```Dockerfile``` will produce 3 different binaries:

- 64 bit libFuzzer-based fuzzer with ASAN and UBSAN
- 32 bit libFuzzer-based fuzzer with ASAN and UBSAN
- 64 standalone loader to be subjected to symbolic execution and advanced triage

### Debugging

Once a crash has been observed, compile the harness with ```-DDEBUG```
to enable verbosity and run it on the crashing input.

### Notes

Some code, in particular the `serialize` method in `serialize.h` could
be refactored using templates to occupy less space (at the source code
level). However, due to heavy use of C++ templating elsewhere,
compilation is already fairly slow (especially if LLVM sanitizers are
used), so further templating may be undesirable.


## Bugs beyond the CVEs

To find a description of the CVEs and how we fuzzed cereal, check out
the ForAllSecure [blog post](https://blog.forallsecure.com).

In addition to the CVEs, there are many interesting bugs.

### XML null pointer dereference

Loading untrusted XML can lead to a null pointer dereference:

```cpp
#include <cereal/archives/xml.hpp>

int main(void)
{
	const std::string s = "<?xml version=\"1.0\" encoding=\"utf-8\"?><cereal><?>a</?></cereal>";

	std::stringstream ss(s);
	cereal::XMLInputArchive archiveFrom(ss);
	char c;
	archiveFrom(c);
	return 0;
}
```

### XML outputs uninitialized memory

Running the below with valgrind indicates that the `v` remains
uninitialized after apparently successfully deserializing it.


```cpp
#include <cereal/archives/xml.hpp>
#include <string>

int main(void)
{
	std::stringstream ss(std::string("<?xml version=\"1.0\" encoding=\"utf-8\"?><cereal><value0></value0></cereal>"));
	cereal::XMLInputArchive ar(ss);
	bool v;
	ar(v);
	printf("%d\n", v);
	return 0;
}
```


This happens because cereal’s internal string to bool conversion
mechanism does not check if the conversion failed. It does not call
`fail()` after the conversion to see if it succeeded. This leaves the
target value uninitialized.


### XML stack overflow

The following example will crash:

```cpp
#include <cereal/archives/xml.hpp>

int main(void)
{
	std::string s;
	for (size_t i = 0; i < (1024 * 1024); i++) {
    	s += "<<>";
	}
	std::stringstream ss(s);
	try {
    	cereal::XMLInputArchive archiveFrom(ss);
	} catch ( ... ) { }
	return 0;
}
```

This is because there is an unbounded recursion in rapidxml.hpp:

`parse_element() -> parse_node_contents() -> parse_node() -> parse_element()`


### JSON stack overflow

Very similar to the XML stack overflow, parsing a JSON file with many
nested elements leads to a stack overflow:

```cpp
#include <cereal/archives/json.hpp>

int main(void)
{
	std::string s(1024*1024, '[');
	std::stringstream ss(s);
	try {
    	cereal::JSONInputArchive archiveFrom(ss);
	} catch ( ... ) { }
	return 0;
}
```

This is actually a bug in (rapidjson)[https://rapidjson.org/], which
is the JSON parsing library that cereal uses.

### JSON branching on uninitialized memory

```cpp
#include <cereal/archives/json.hpp>

int main(void)
{
	const std::string s("{\"\":1}");
	std::stringstream ss(s);
	cereal::JSONInputArchive archiveFrom(ss);
	int a;
	long double b;
	archiveFrom(a);
	archiveFrom(b);
	return 0;
}
```

Compiled without AddressSanitizer, the output is:

```
terminate called after throwing an instance of 'cereal::RapidJSONException'
  what():  rapidjson internal assertion failure: IsString()
```

Compiled with AddressSanitizer (which initializes otherwise
uninitialized bytes), the output it:

```
terminate called after throwing an instance of 'std::invalid_argument'
  what():  stold
```

The access to uninitialized memory happens in rapidjson, in `document.h`:

```cpp
const Ch* GetString() const {
    CEREAL_RAPIDJSON_ASSERT(IsString());
    return (data_.f.flags & kInlineStrFlag) ? data_.ss.str : GetStringPointer();
}
```

Let’s break this down. There are two statements in here:

```cpp
CEREAL_RAPIDJSON_ASSERT(IsString());
return (data_.f.flags & kInlineStrFlag) ? data_.ss.str : GetStringPointer();
```

The first statement accesses `data_.f.flags`. This variable is
uninitialized, and depending on its value, an exception will or will
not be thrown.

If the memory layout is such that no exception is thrown, the second
statement is executed. Again, this accesses `data_.f.flags`, which is
still uninitialized.

Depending on which value it has, the function will return either
`data_.ss.str`, or `GetStringPointer()`.

`data_.ss.str` is an array of about 14 bytes, which is also
uninitialized, and in most cases will contain gibberish. If
`data_.ss.str` is returned, it will be attempted to be converted to a
`long double`. Because it is gibberish, conversion fails, and `stold`
will throw an invalid argument exception.

The takeaway is that if there are two values attempted to be
deserialized, from an input JSON string that encodes only one value,
the second value can be processed from an uninitialized buffer
(`data_.ss.str`).

Let’s change the second target value from long double to `std::string`:

```cpp
#include <cereal/archives/json.hpp>
#include <cereal/types/string.hpp>

int main(void)
{
	const std::string s("{\"\":1}");
	std::stringstream ss(s);
	cereal::JSONInputArchive archiveFrom(ss);
	int a;
	std::string b;
	archiveFrom(a);
	archiveFrom(b);

	printf("%s\n", b.c_str());
	return 0;
}
```

Compile this with AddressSanitizer and run. Gibberish will be printed
to the screen. This indicates that uninitialized memory has ended up
in the target string. If that string is then exposed to the outside,
that could constitute a data breach.

### Container types denial of service

cereal does not constrain the size of C++ container types
(`std::string`, `std::vector`, `std::stack` and so on) specified by
the input archive. This can lead to denial-of-service situations.

This issue has been observed with Binary and PortableBinary archives,
but not with JSON and XML archives.

The following example will allocate gigabytes of memory from a mere 10
byte input archive:

```cpp
#include <cereal/archives/binary.hpp>
#include <cereal/types/string.hpp>

int main(void)
{
	unsigned char data[] = {0x0a, 0x00, 0x00, 0x83,
                            0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00};

	const std::string s(data, data + sizeof(data));
	std::stringstream ss(s);
	cereal::BinaryInputArchive archiveFrom(ss);
	std::string c;
	try {
    	archiveFrom(c);
	} catch ( ... ) { }
	return 0;
}
```

This happens because cereal resizes the target string upfront to hold
as much data as the input archive claims to provide, even if the
archive is in fact empty.


### Serialization symmetry

In my opinion, an underappreciated aspect of the security of
serialization code is asserting that it is always symmetrical;
whatever data you pass into it (serialization), must come out of it
(deserialization) the same way.

You are logged in to your bank’s website and send $10.00 to a friend’s
account. Your web browser serializes your request into JSON and
transmits it over a secure connection. Your bank receives the request,
and parses the JSON. Due to a bug in their JSON parser, the amount is
incorrectly interpreted and instead of $10.00, $1000 is sent.

This is a contrived example that does not reflect our day-to-day
banking experience; but the devil is in the details and adversity
looms in those corner cases where static test suites and bare-minimum
fuzzers have not ventured.

How will the bank react when you try to send an amount with a large
fractional part, like $3.1415926535 (bearing in mind that software
usually relies on floating point representations that have finite
granularity). Will it send $3.14, or something else entirely?

What does the bank do when you send $2147483648 (which is larger than
a signed 32 bit integer can hold)?

In my cereal fuzzer, I invested heavily into asserting that what goes
in, also comes out, verbatim. To this end, I used XXHash, which is a
very fast hashing algorithm.

In the serialization phase, all data that is passed to cereal, is also
passed to `XXHash`. I end up with a hash computed over all the input
data. I store this hash for later reference.

For the deserialization phase, I create a new instance of `XXHash`, and
compute a hash of all the data that comes out of cereal.

I then compare both hashes, and aborts the program if they mismatch,
warranting further inspection.

Using this technique, I found several interesting bugs in cereal.

### `std::string` cannot contain null bytes

If an input `std::string` contains a null byte, both the JSON and XML
backends fail to deserialize it back into the original value.

```cpp
#include <cereal/archives/json.hpp>
#include <cereal/archives/xml.hpp>

template <class InputArchive, class OutputArchive>
void serialize(void) {
	const unsigned char data[] = {0xFF, 0x00, 0xFF};
	std::string s(data, data + sizeof(data));

	printf("\tInput:\t");
	for (size_t i = 0; i < s.size(); i++) {
    	printf("%02X ", (unsigned char)(s[i]));
	}
	printf("\n");

	std::stringstream ss;
	{
    	OutputArchive archiveTo(ss);
    	archiveTo(s);
	}

	InputArchive archiveFrom(ss);
	std::string s2;
	archiveFrom(s2);
	printf("\tOutput:\t");
	for (size_t i = 0; i < s2.size(); i++) {
    	printf("%02X ", (unsigned char)(s2[i]));
	}
	printf("\n");

	printf("\n");
}

int main(void)
{
	printf("JSON:\n");
    serialize<cereal::JSONInputArchive, cereal::JSONOutputArchive>();
	printf("XML:\n");
    serialize<cereal::XMLInputArchive, cereal::XMLOutputArchive>();
	return 0;
}
```

This outputs:

```
JSON:
    Input:    FF 00 FF
    Output:    FF

XML:
    Input:    FF 00 FF
    Output:    FF
```

### XML injection

In cases where either JSON or XML are used as the target archive,
cereal supports assigning a name to each variable. I wanted to put to
the test how cereal reacts if you use strange names for variables, as
there may be use cases where an attacker has (some) influence over the
variable names.

```cpp
#include <cereal/archives/xml.hpp>

template <class InputArchive, class OutputArchive>
void serialize(void) {

	char cIn = 'a';
	std::stringstream ss;
	{
    	OutputArchive archiveTo(ss);
    	archiveTo(cereal::make_nvp("a>b", cIn));
	}

	printf("Archive is:\n%s\n", ss.str().c_str());
	InputArchive archiveFrom(ss);
	char cOut;
	archiveFrom(cOut);
	if ( cIn != cOut ) {
    	printf("Serialization asymmetry: %d vs %d\n", cIn, cOut);
	}
}

int main(void)
{
	serialize<cereal::XMLInputArchive, cereal::XMLOutputArchive>();
	return 0;
}
```

The first argument to `cereal::make_nvp` is `a>b`. The resulting
output archive is:

```xml
<?xml version="1.0" encoding="utf-8"?>
<cereal>
    <a>b>a<a>b>>
</cereal>
```

In bold script are the places where cereal inserted the name. Despite
looking a bit funny for XML, this actually parses without problems.


## TODO

Several types still need support. See ```cereal/include/types```. You
could find new CVEs :)

Compile with MemorySanitizer.



## Credits

The vulnerabilities, code, and write up were created by Guido Vranken.
